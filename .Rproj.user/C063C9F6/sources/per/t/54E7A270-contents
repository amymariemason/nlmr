setwd("U:/My Documents/eGFR/writeup/NLMR/MVP")
require(methods)
require(parallel)
require(metafor)
require(ggplot2)
require(matrixStats)
require(survival)
source("nlmr_functions.r")
# function for making a dataset with Prentice weights - not needed for MVP
source("../prentice_weighted_dset.r")
source("nlme_summ_aes MA.r")

### LOAD AND PROCESS EPIC-CVD DATA ###
# main data
epic <- read.csv("X:\\Biobank\\Analysis\\P31852\\RENAL\\data\\EPICCVD\\followup.csv", as.is=TRUE)
# genetic ID -> EPIC-CVD ID mapping file
genids <- read.csv("X:\\Biobank\\Analysis\\P31852\\RENAL\\data\\EPICCVD\\GENIDS.csv", as.is=TRUE)
# GRS generated by Steven Bell; IDs are the genetic IDs
epic_grs <- read.table("X:/Biobank/Analysis/P31852/RENAL/data/GRS/Risk scores/EPIC_GRS_eGFR.txt", sep="\t", header=TRUE)


epic <- merge(epic, genids, by.x="id", by.y="id", all.x=TRUE, all.y=FALSE)
# restrict to people with genetic IDs
epic <- epic[!is.na(epic$genid3),]
epic <- merge(epic, epic_grs, by.x="genid3", by.y="iid", all.x=TRUE, all.y=FALSE)

# standardise the subcohort flag
epic$subcohort <- toupper(epic$subcohort)

# check we have all the relevant variables and outcomes
table(epic$cohort, is.na(epic$creat3))
epic <- epic[!is.na(epic$creat3), ]
epic <- epic[!is.na(epic$ages), ]
epic <- epic[!is.na(epic$sex), ]
epic <- epic[!is.na(epic$ep1_cvd), ]
epic <- epic[!is.na(epic$epic_egfr_grs), ]

# numeric flag for sex
epic$sex <- toupper(epic$sex)
epic$sex_i <- ifelse(toupper(epic$sex) == "MALE",1,2)

# create indicator variables for outcomes
for (vv in grep("ep1", names(epic), value=TRUE)) {
	epic[paste0(vv, "_i")] <- ifelse(toupper(epic[[vv]])=="YES",1,0)
}

# Generate eGFR 
epic$egfr <- egfr(creat = epic$creat3, age=epic$ages, sex=epic$sex)


### NLMR SET-UP ###
## assumes you have eGFR values, eGFR GRS

# generate a mean-centred copy of the GRS
epic$egfr_grs_centre <- epic$epic_egfr_grs - mean(epic$epic_egfr_grs)

# generate fitted values of eGFR based on the GRS, and IV-free versions of eGFR
epic$egfr_grs_fitted <- fitted(lm(egfr ~ egfr_grs_centre, data=epic))
epic$egfr_grs_beta <- lm(egfr ~ egfr_grs_centre, data=epic)$coef[2]
epic$egfr_genetic_component <- epic$egfr_grs_centre * epic$egfr_grs_beta
epic$egfr_nongenetic <- epic$egfr - epic$egfr_genetic_component
epic$egfr_residual <- epic$egfr - epic$egfr_grs_fitted



# generate quantiles of the IV-free exposure
n_q <- 15
epic$egfr_nongenetic_q <- cut(epic$egfr_nongenetic, breaks=quantile(epic$egfr_nongenetic, probs=seq(0,1,length.out=n_q+1)), labels=FALSE, include.lowest=TRUE)
epic$egfr_q <- cut(epic$egfr, breaks=quantile(epic$egfr, probs=seq(0,1,length.out=n_q+1)), labels=FALSE, include.lowest=TRUE)
q_index <- sort(unique(epic$egfr_nongenetic_q))

# generate groups of IV-exposure based on our CKD groups (extended version)
epic$egfr_nongenetic_ckd <- cut(epic$egfr_nongenetic, breaks=c(0,45,seq(60,120,by=15),300), labels=FALSE, include.lowest=TRUE)
epic$egfr_ckd <- cut(epic$egfr, breaks=c(0,45,seq(60,120,by=15),300), labels=FALSE, include.lowest=TRUE)
q_ckd_index <- sort(unique(epic$egfr_nongenetic_ckd))


# need mean levels of non-genetic eGFR in these quantiles
egfr_q_xmeans <- sapply(q_index, function(z) mean(epic$egfr[epic$egfr_nongenetic_q == z]))
egfr_q_ckd_xmeans <- sapply(q_ckd_index, function(z) mean(epic$egfr[epic$egfr_nongenetic_ckd == z]))


# generate datasets with Prentice weights for the outcomes of interest in EPIC-CVD
# this step isn't needed for MVP and the function grs_outcome() needs to be modified to do the right thing
cvd_prentice <- prentice_weighted_dset(indata=epic, outcome="ep1_cvd_i", subcohort_var="subcohort", subcohort_true_val="MEMBER")
chd_prentice <- prentice_weighted_dset(indata=epic, outcome="ep1_chd_i", subcohort_var="subcohort", subcohort_true_val="MEMBER")
stroke_prentice <- prentice_weighted_dset(indata=epic, outcome="ep1_stroke_i", subcohort_var="subcohort", subcohort_true_val="MEMBER")


# test a simple example - all the Cox regressions are of this form so 
# worth testing what the MVP Cox regression will look like here
fit_test <- coxph(Surv(time=duration1_cvd, event=ep1_cvd_i_wt) ~ egfr_grs_centre + offset(wt_pre) + cluster(id) + strata(centreEH), data=cvd_prentice)
summary(fit_test)




# generate the GRS - outcome associations for all the outcomes x possible groupings
grs_cvd <- sapply(q_index, grs_outcome, q_var="egfr_nongenetic_q", indata=cvd_prentice, outcome="ep1_cvd_i_wt", timevar="duration1_cvd")
grs_cvd_ckd <- sapply(q_ckd_index, grs_outcome, q_var="egfr_nongenetic_ckd", indata=cvd_prentice, outcome="ep1_cvd_i_wt", timevar="duration1_cvd")

grs_chd <- sapply(q_index, grs_outcome, q_var="egfr_nongenetic_q", indata=chd_prentice, outcome="ep1_chd_i_wt", timevar="duration1_chd")
grs_chd_ckd <- sapply(q_ckd_index, grs_outcome, q_var="egfr_nongenetic_ckd", indata=chd_prentice, outcome="ep1_chd_i_wt", timevar="duration1_chd")

grs_stroke <- sapply(q_index, grs_outcome, q_var="egfr_nongenetic_q", indata=stroke_prentice, outcome="ep1_stroke_i_wt", timevar="duration1_stroke")
grs_stroke_ckd <- sapply(q_ckd_index, grs_outcome, q_var="egfr_nongenetic_ckd", indata=stroke_prentice, outcome="ep1_stroke_i_wt", timevar="duration1_stroke")


# generate GRS - exposure associations across strata
grs_exposure_mean_se <- sapply(q_index, grs_exposure, q_var="egfr_nongenetic_q", indata=epic)
grs_exposure_mean_se_ckd <- sapply(q_ckd_index, grs_exposure, q_var="egfr_nongenetic_ckd", indata=epic)

# combine these estimates into single GRS - exposure association across range of eGFR
grs_exposure_overall <- est_overall_grs_exposure(grs_exposure_mean_se)
grs_exposure_overall_ckd <- est_overall_grs_exposure(grs_exposure_mean_se_ckd)
# test of IV-exposure assumption 
p_het <- 1 - pchisq(rma(grs_exposure_mean_se[1,], vi=grs_exposure_mean_se[2,]^2)$QE, df=(length(q_index)-1))
p_het_trend <- rma.uni(grs_exposure_mean_se[1,] ~ egfr_q_xmeans, vi=grs_exposure_mean_se[2,]^2, method="DL")$pval[2]


# compute LACE estimates
lace <- lace_estimates(grs_cvd, grs_exposure_overall)
lace_ckd <- lace_estimates(grs_cvd_ckd, grs_exposure_overall_ckd)




## basic piecewise plot
plot(c(0,0), xlim=c(0,160), ylim=c(log(0.4),log(32)), xlab="eGFR", ylab="HR for CHD", col=NA)
# this function uses the parallel package to run bootstrap simulations 
# to get the "confidence intervals" - adjust the ncores parameter to something
# reasonable for your computer (1 is fine and should work) 
plot_piecewise_shape(calculate_piecewise_shape(indata=epic, q_var="egfr_q", xref=90, grs_outcome=grs_chd, grs_exposure=grs_exposure_mean_se), nboot=5000, ncores=8)

## basic fractional polynomial curve, using Stephen Burgess's code
plot(c(0,0), xlim=c(0,160), ylim=c(log(0.4),log(32)), xlab="eGFR", ylab="HR for CHD", col=NA)
plot_fp_curve(frac_poly_summ_mr(by=grs_chd[1,], 
					byse=grs_chd[2,], 
					bx=grs_exposure_mean_se[1,], 
					bxse=grs_exposure_mean_se[2,], 
					xmean=egfr_q_xmeans,
					ref=90,
					method="FE", d=1, powers=c(0, -2, -1.5, -1, -0.5, 1, 2),
					fig=TRUE))
	